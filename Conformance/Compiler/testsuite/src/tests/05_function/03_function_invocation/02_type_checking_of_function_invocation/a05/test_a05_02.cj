/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 * 
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/*
  @Name:            05_03_02_a05_02

  @Level:         1

  @Assertion:       5.3.2(5) Assume that the function is defined as: 
                        ğ‘“ğ‘– < ğ‘‡ğ‘–1 , ..., ğ‘‡ğ‘–ğ‘ > (ğ´ğ‘–1 , ..., ğ´ğ‘–ğ‘˜ ) âˆ¶ ğ‘…ğ‘– ğ‘¤â„ğ‘’ğ‘Ÿğ‘’ ğ¶ğ‘–1 , ..., ğ¶ğ‘–ğ‘ğ‘– 
                    1) If the invoking expression contains the type argument fi<T1, ..., Tp>(A1, ..., Ak), the rule 
                    for checking the type of the fi function is as follows: 
                        a) First, check constraints of the type parameters: the type arguments `<T1, ..., Tp>` must 
                        meet the type constraints of the `fi` function. 
                            ğœ = [ğ‘‡1 â†¦ ğ‘‡ğ‘–1 , ..., ğ‘‡ğ‘ â†¦ ğ‘‡ğ‘–ğ‘]Î” âŠ¢ ğœ ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘  ğ¶ğ‘–1 , ..., ğ¶ğ‘–ğ‘ğ‘– 
                        b) Parameter type checking: after the type arguments are substituted into the parameters of 
                        the function fi, the argument types (A1, ..., Ak) is the subtype of the type after the type 
                        arguments are substituted into the parameters. 
                            ğœ = [ğ‘‡1 â†¦ ğ‘‡ğ‘–1 , ..., ğ‘‡ğ‘ â†¦ ğ‘‡ğ‘–ğ‘]Î” âŠ¢ (ğ´1, ..., ğ´ğ‘˜) <âˆ¶ ğœ(ğ´ğ‘–1 , ..., ğ´ğ‘–ğ‘˜ ) 

                        c) Check the type of the return type : If the context of the calling expression has a specific 
                        type requirement R, after the type arguments are substituted into the return type Ri of the 
                        function fi, the return type after substituted is the subtype of R. 
                            ğœ = [ğ‘‡1 â†¦ ğ‘‡ğ‘–1 , ..., ğ‘‡ğ‘ â†¦ ğ‘‡ğ‘–ğ‘]Î” âŠ¢ ğœğ‘…ğ‘– <âˆ¶ ğ‘…

  @Description:     Check that if arguments types doesn't meet the function definition - an error will be raised.

  @Mode:            compileonly

  @Negative:        yes

  @Structure:       single

*/

type myType = (Int32, Bool)

class myClass {
    func f0<X>(a: X): X where X <: ToString {a}
}

main(): Unit {
    var myVar = (1, false)
    var myClassImpl = myClass()
    myClassImpl.f0<myType>(myVar)
}
