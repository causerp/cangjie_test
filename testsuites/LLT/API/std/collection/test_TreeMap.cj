/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */
// EXEC: %compiler %cmp_opt -o %n.%suffix %f %cmp_utest_opt
// EXEC: %run %run_opt %n.%suffix %run_utest_opt %run_args

import std.collection.*

func isNoneTuple<K, V>(tup: Option<(K, V)>): Bool {
    match (tup) {
        case Some(_) => false
        case None => true
    }
}

func isNoneValue<V>(value: Option<V>): Bool {
    match (value) {
        case Some(_) => false
        case None => true
    }
}

func isNoneNode<K, V>(treeNode: Option<MapEntryView<K, V>>): Bool where K <: Comparable<K> {
    match (treeNode) {
        case Some(_) => false
        case None => true
    }
}

func isEmptyIterator<K, V>(iter: Iterator<(K, V)>): Bool {
    for (_ in iter) {
        return false
    }
    return true
}

let elementsRemove: Array<(String, Int64)> = [("èµµ", 1), ("é’±", 2), ("å­™", 3), ("æ", 4), ("Y", 57), ("z", 58), ("ğŸ˜ƒ", 59),
    ("(â—'â—¡'â—)", 60), ("å‘¨", 5), ("å´", 6), ("éƒ‘", 7), ("ç‹", 8), ("a", 33), ("B", 34), ("c", 35), ("D", 36), ("å†¯", 9),
    ("é™ˆ", 10), ("è¤š", 11), ("å«", 12), ("è’‹", 13), ("æ²ˆ", 14), ("éŸ©", 15), ("æ¨", 16), ("i", 41), ("G", 42), ("K", 43),
    ("l", 44), ("æœ±", 17), ("ç§¦", 18), ("å°¤", 19), ("è®¸", 20), ("ä½•", 21), ("å•", 22), ("æ–½", 23), ("å¼ ", 24), ("Q", 49),
    ("r", 50), ("S", 51), ("t", 52), ("å­”", 25), ("æ›¹", 26), ("ä¸¥", 27), ("å", 28), ("U", 53), ("v", 54), ("W", 55),
    ("x", 56), ("é‡‘", 29), ("é­", 30), ("é™¶", 31), ("å§œ", 32), ("e", 37), ("F", 38), ("g", 39), ("H", 40), ("M", 45),
    ("n", 46), ("O", 47), ("p", 48), ("æˆš", 45), ("è°¢", 46), ("é‚¹", 47), ("å–»", 48), ("æŸ", 49), ("æ°´", 50), ("çª¦", 51),
    ("ç« ", 52), ("äº‘", 53), ("è‹", 54), ("æ½˜", 55), ("è‘›", 56), ("å¥š", 57), ("èŒƒ", 58), ("å½­", 59), ("éƒ", 60),
    ("é²", 61), ("éŸ¦", 62), ("æ˜Œ", 63), ("é©¬", 64), ("è‹—", 65), ("å‡¤", 66), ("èŠ±", 67), ("æ–¹", 68), ("ä¿", 69),
    ("ä»»", 70), ("è¢", 71), ("æŸ³", 72), ("é…†", 73), ("é²", 74), ("å²", 75), ("å”", 76), ("è´¹", 77), ("å»‰", 78),
    ("å²‘", 79), ("è–›", 80), ("é›·", 81), ("è´º", 82), ("å€ª", 83), ("æ±¤", 84), ("æ»•", 85), ("æ®·", 86), ("ç½—", 87),
    ("æ¯•", 88), ("éƒ", 89), ("é‚¬", 90), ("å®‰", 91), ("å¸¸", 92), ("ä¹", 93), ("äº", 94), ("æ—¶", 95), ("å‚…", 96), ("ğŸ˜¢", 97),
    ("ğŸ˜Š", 98), ("ğŸ˜‚", 99), ("ğŸ¤£", 100), ("<", 101), (">", 102), (":", 103), (";", 104), ("â¤", 105), ("ğŸ§¡", 106), ("ğŸ’›", 107),
    ("ğŸ’š", 108), ("ğŸ’™", 109), ("ğŸ’œ", 110), ("ğŸ¤", 111), ("ğŸ–¤", 112), ("â„ƒ", 113), ("Â¥", 114), ("Â£", 115), ("â€²", 116),
    ("ãœ", 117), ("ã", 118), ("ã„", 119), ("Â¤", 120), ("1", 121), ("3", 122), ("5", 123), ("7", 124), ("9", 125),
    ("2", 126), ("4", 127), ("6", 128), ("!", 129), ("@", 130), ("#", 131), ("%", 132), ("^", 133), ("&", 134),
    ("*", 135), ("()", 136), ("â†", 137), ("â†“", 138), ("â†–", 139), ("â†™", 140), ("â†‘", 141), ("â†”", 142), ("â†—", 143),
    ("â‡ ", 144)]
let elementsNames: Array<(String, Int64)> = [("èµµ", 1), ("é’±", 2), ("å­™", 3), ("æ", 4), ("å‘¨", 5), ("å´", 6), ("éƒ‘", 7),
    ("ç‹", 8), ("å†¯", 9), ("é™ˆ", 10), ("è¤š", 11), ("å«", 12), ("è’‹", 13), ("æ²ˆ", 14), ("éŸ©", 15), ("æ¨", 16), ("æœ±", 17),
    ("ç§¦", 18), ("å°¤", 19), ("è®¸", 20), ("ä½•", 21), ("å•", 22), ("æ–½", 23), ("å¼ ", 24)]

@Test
class TreeMapTest {
    @TestCase
    func initWithoutParameter(): Unit {
        var map1: TreeMap<String, String> = TreeMap<String, String>()
        @Expect(map1.size, 0)
        var map2: TreeMap<String, Int64> = TreeMap<String, Int64>()
        @Expect(map2.size, 0)

        var map3: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(map3.size, 0)
    }

    @TestCase
    func initByCollection(): Unit {
        var col: Collection<(Int64, Int64)> = [(1, 2), (2, 3), (3, 4)]
        var map: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(col)
        var res: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>([(1, 2), (2, 3), (3, 4)])
        @Expect(map.size, 3)
        @Expect(map, res)
    }

    @TestCase
    func initByArray(): Unit {
        var arr: Array<(Int64, Int64)> = [(3, 4), (2, 3), (1, 2)]
        var map: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(arr)
        var res: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>([(1, 2), (2, 3), (3, 4)])
        @Expect(map.size, 3)
        @Expect(map, res)

        const N: Int64 = 300000
        let elements1 = Array<(Int64, Int64)>(N, {i => (i, i + 5)})
        let treemap1 = TreeMap<Int64, Int64>(elements1)

        let res1 = Array<Int64>(N, repeat: -1)
        let resArr1 = Array<Int64>(N, {i => i + 5})
        for ((k, v) in treemap1) {
            res1[k] = v
        }
        @Expect(res1,resArr1)

        let elements2 = HashMap<String, Int64>(
            [("èµµ", 1), ("é’±", 2), ("å­™", 3), ("æ", 4), ("å‘¨", 5), ("å´", 6), ("éƒ‘", 7), ("ç‹", 8), ("å†¯", 9),
                ("é™ˆ", 10), ("è¤š", 11), ("å«", 12), ("è’‹", 13), ("æ²ˆ", 14), ("éŸ©", 15), ("æ¨", 16)])
        let treemap2 = TreeMap<String, Int64>(elements2)
        let size = treemap2.size

        let res2 = Array<Int64>(size, repeat: -1)
        let resArr2: Array<Int64> = [9, 12, 6, 5, 3, 4, 16, 14, 8, 13, 11, 1, 7, 2, 10, 15]
        var i = 0
        for ((_, v) in treemap2) {
            res2[i] = v
            i++
        }

        @Expect(res2,resArr2)
    }

    @TestCase
    func initByFunction(): Unit {
        var map: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x: Int64 => (x, x * x)})
        var res1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(
            [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)])
        @Expect(map.size, 10)
        @Expect(map, res1)

        try {
            var _ = TreeMap<Int64, Int64>(-10, {K => (K, K)})
            @Expect("Should throw exception", "")
        } catch (e: IllegalArgumentException) {
            @Expect(e.message, "Invalid size of TreeMap: -10.")
        }

        const N: Int64 = 1000
        let treemap = TreeMap<Int64, Int64>(N, {i => (N - 1 - i, N - 1 - i)})
        let size = treemap.size

        let res2 = Array<Int64>(size, repeat: -1)
        let resArr = Array<Int64>(N, {i => i})
        for ((k, v) in treemap) {
            res2[k] = v
        }

        @Expect(res2,resArr)

        try {
            let _ = TreeMap<Int64, Int64>(-1, {i => (i, i)})
            @Assert(false)
        } catch (e: IllegalArgumentException) {
            @Expect(e.message,"Invalid size of TreeMap: -1.")
        }
    }

    @TestCase
    func clone(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(map1.clone().isEmpty())
        var map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x: Int64 => (x, x * x)})
        var map22 = map2.clone()
        @Expect(!map22.isEmpty())
        @Expect(map22.size, 10)
    }

    @TestCase
    func iterator(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        try {
            map1.iterator().next().getOrThrow()
            @Expect("Should throw exception", "map1.iterator().next().getOrThrow()")
        } catch (e: Exception) {
            @Expect(e.message, "")
        }

        var map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x: Int64 => (x, x * x)})
        var iter2 = map2.iterator()
        var keyValue2 = iter2.next().getOrThrow()
        @Expect(keyValue2[0], 0)
        @Expect(keyValue2[1], 0)

        let treemap = TreeMap<String, Int64>(elementsNames)
        let iter3 = treemap.iterator()
        for ((k, v) in iter3) {
            @Expect(treemap[k], v)
        }

        treemap.removeFirst()
        @Expect(treemap.size, 23)

        try {
            iter3.next()
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }
    }

    @TestCase
    func backwardAndForward(): Unit {
        let treemap = TreeMap<Int64, Int64>(5, {x: Int64 => (2 * x, 2 * x)})
        // Exist Key
        @Expect(treemap.forward(2, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>(4, {x: Int64 => (2*(x+1), 2*(x+1))}))
        @Expect(treemap.forward(2, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>(3, {x: Int64 => (2*(x+2), 2*(x+2))}))

        @Expect(treemap.backward(2, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>((2, 2), (0, 0)))
        @Expect(treemap.backward(2, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>((0, 0)))

        @Expect(treemap.forward(0, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>(5, {x: Int64 => (2*x, 2*x)}))
        @Expect(treemap.forward(0, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>((2, 2), (4, 4), (6, 6), (8, 8)))

        @Expect(treemap.backward(8, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>(5, {x: Int64 => (2*x, 2*x)}))
        @Expect(treemap.backward(8, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>((0, 0), (2, 2), (4, 4), (6, 6)))

        // Not exist key
        @Expect(treemap.backward(10, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>(5, {x: Int64 => (2*x, 2*x)}))
        @Expect(treemap.backward(10, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>(5, {x: Int64 => (2*x, 2*x)}))

        @Expect(treemap.forward(-10, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>(5, {x: Int64 => (2*x, 2*x)}))
        @Expect(treemap.forward(-10, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>(5, {x: Int64 => (2*x, 2*x)}))

        @Expect(treemap.backward(3, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>((0, 0), (2, 2)))
        @Expect(treemap.backward(3, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>((0, 0), (2, 2)))

        @Expect(treemap.forward(3, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>((4, 4), (6, 6), (8, 8)))
        @Expect(treemap.forward(3, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>((4, 4), (6, 6), (8, 8)))

        @Expect(treemap.forward(10, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>())
        @Expect(treemap.forward(10, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>())

        @Expect(treemap.backward(-11, inclusive: true) |> collectHashMap, HashMap<Int64, Int64>())
        @Expect(treemap.backward(-11, inclusive: false) |> collectHashMap, HashMap<Int64, Int64>())
    }

    @TestCase
    func toString(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(map1.toString(), "[]")
        var map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x: Int64 => (x, x * x)})
        @Expect(map2.toString(),
            "[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)]")
    }

    @TestCase
    func firstEntryGetAndPop(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(isNoneTuple(map1.removeFirst()))
        @Expect(isNoneTuple(map1.first))

        let treemap = TreeMap<String, Int64>(elementsNames)
        var first = treemap.first.getOrThrow()
        @Expect(first[0], "ä½•")
        @Expect(first[1], 21)

        first = treemap.removeFirst().getOrThrow()
        @Expect(first[0], "ä½•")
        @Expect(first[1], 21)

        first = treemap.first.getOrThrow()
        @Expect(first[0], "å†¯")
        @Expect(first[1], 9)

        treemap.removeIf({k, _ => (k >= "å†¯" && k < "éŸ©")})
        first = treemap.first.getOrThrow()
        @Expect(first[0], "éŸ©")
        @Expect(first[1], 15)

        first = treemap.removeFirst().getOrThrow()
        @Expect(first[0], "éŸ©")
        @Expect(first[1], 15)

        @Assert(isNoneTuple(treemap.removeFirst()))
        @Assert(isNoneTuple(treemap.first))
        @Expect(treemap.toString(), "[]")
    }

    @TestCase
    func lastEntryGetAndPop(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(isNoneTuple(map1.removeLast()))
        @Expect(isNoneTuple(map1.last))

        let treemap = TreeMap<String, Int64>(elementsNames)
        var last = treemap.last.getOrThrow()
        @Expect(last[0], "éŸ©")
        @Expect(last[1], 15)

        last = treemap.removeLast().getOrThrow()
        @Expect(last[0], "éŸ©")
        @Expect(last[1], 15)

        last = treemap.last.getOrThrow()
        @Expect(last[0], "é™ˆ")
        @Expect(last[1], 10)

        treemap.removeIf({k, _ => (k >= "ä½•" && k < "é™ˆ")})
        last = treemap.last.getOrThrow()
        @Expect(last[0], "é™ˆ")
        @Expect(last[1], 10)
        last = treemap.removeLast().getOrThrow()
        @Expect(last[0], "é™ˆ")
        @Expect(last[1], 10)

        @Assert(isNoneTuple(treemap.removeLast()))
        @Assert(isNoneTuple(treemap.last))
        @Expect(treemap.toString(), "[]")
    }

    @TestCase
    func OrderedMapEntryView(): Unit {
        var treemap: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>((0, 0), (2, 22), (4, 4), (8, 8))

        var node1 = treemap.entryView(2)
        @Expect(node1.key, 2)
        @Expect(node1.value, 22)
        node1.value = 2

        var sum = 0
        var node2 = treemap.entryView(-1)
        @Expect(node2.key, -1)

        try {
            node2.value
        } catch (e: NoneValueException) {
            sum += 1
        }

        let view = treemap.entryView(1)
        view.value = 1
        @Expect(treemap.get(1), 1)
        @Expect(view.value, 1)
        @Expect(sum, 1)
    }

    @TestCase
    func nodeConcurrentModificationException(): Unit {
        const N: Int64 = 36
        let treemap = TreeMap<Int64, Int64>(N, {i => (2 * i - 36, i)})
        var iter = treemap.backward(0, inclusive: true)
        var node = treemap.entryView(iter.next().getOrThrow()[0])
        node.value = 100
        @Expect(node.value, 100)

        treemap.add(0, 101)
        @Expect(node.value, 101)

        treemap.remove(node.key)
        try {
            node.key == 102
            @Expect("Should throw exception", "node.key == 102")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }

        try {
            node.value = 102
            @Expect("Should throw exception", "node.value = 102")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }

        try {
            node.value == 102
            @Expect("Should throw exception", "node.value == 102")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }

        try {
            iter.next
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }

        try {
            treemap.backward(node.key, inclusive: true)
            @Expect("Should throw exception", "node.prev()")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }

        iter = treemap.backward(38, inclusive: true)
        node = treemap.entryView(iter.next().getOrThrow()[0])
        @Expect(node.key, 34)
        treemap.removeLast()
        try {
            iter.next()
            @Expect("Should throw exception", "node.forward(29)")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }

        iter = treemap.forward(30, inclusive: false)
        node = treemap.entryView(iter.next().getOrThrow()[0])
        @Expect(node.key, 32)
        treemap.add(99, 99)
        try {
            iter.next()
            @Expect("Should throw exception", "tree.backward(99)")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "")
        }
    }

    @TestCase
    func getAndOperatorGet(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(map1.get(1), Option<Int64>.None)
        try {
            var _ = map1[1]
            @Expect("Should throw exception", "var _ = map1[1]")
        } catch (e: NoneValueException) {
            @Expect(e.message, "Value does not exist!")
        }

        let eleNames: Array<(String, Int64)> = [("èµµ", 1), ("é’±", 2), ("å­™", 3), ("æ", 4), ("å‘¨", 5), ("å´", 6),
            ("éƒ‘", 7), ("ç‹", 8), ("å†¯", 9), ("é™ˆ", 10), ("è¤š", 11), ("å«", 12), ("è’‹", 13), ("æ²ˆ", 14), ("éŸ©", 15),
            ("æ¨", 16)]
        let treemap = TreeMap<String, Int64>(eleNames)
        let size = treemap.size

        let res = ["èµµ", "é’±", "å­™", "æ", "å‘¨", "å´", "éƒ‘", "ç‹", "å†¯", "é™ˆ", "è¤š", "å«", "è’‹", "æ²ˆ", "éŸ©", "æ¨"]
        let resArr1 = Array<Int64>(size, repeat: -1)
        let resArr2 = Array<Int64>(size, {i => i + 1})
        for (i in 0..size) {
            resArr1[i] = treemap.get(res[i]).getOrThrow()
        }

        @Assert(isNoneValue(treemap.get("èµµ\0")))

        @Expect(resArr1,resArr2)
    }

    @TestCase
    func containsAndAll(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(!map1.contains(1))
        @Expect(!map1.contains(all: [1, 2]))

        let treemap = TreeMap<String, Int64>(elementsNames)
        let elements1 = ["èµµ", "é’±", "å­™", "æ", "å‘¨", "å´", "éƒ‘", "ç‹", "å†¯", "é™ˆ", "è¤š", "å«", "è’‹", "æ²ˆ", "éŸ©", "æ¨",
            "æœ±", "ç§¦", "å°¤", "è®¸", "ä½•", "å•", "æ–½", "å¼ "]
        for (key in elements1) {
            @Expect(treemap.contains(key),true)
        }

        let elements2 = ["èµµ ", "é’±\b", "å­™\n", "æ\0", "å‘¨`", "å´  ", "éƒ‘\u{123}", "ç‹\t", "å†¯\\"]
        for (key in elements2) {
            @Expect(treemap.contains(key),false)
        }

        let elements11 = ["èµµ", "é’±", "å­™", "æ", "å‘¨", "å´", "éƒ‘", "ç‹", "å†¯", "é™ˆ", "è¤š", "å«", "è’‹", "æ²ˆ", "éŸ©", "æ¨",
            "æœ±", "ç§¦", "å°¤", "è®¸", "ä½•", "å•", "æ–½", "å¼ "]
        @Expect(treemap.contains(all: elements11),true)

        let elements22 = ["èµµ ", "é’±\b", "å­™\n", "æ\0", "å‘¨`", "å´  ", "éƒ‘\u{123}", "ç‹\t", "å†¯\\"]
        @Expect(treemap.contains(all: elements22),false)

        let elements33 = ["é™ˆ", "è¤š", "å«shi", "è’‹", "æ²ˆ", "éŸ©", "æ¨", "æœ±", "ç§¦", "å°¤", "è®¸", "ä½•", "å•", "æ–½", "å¼ "]
        @Expect(treemap.contains(all: elements33),false)
    }

    @TestCase
    func addAndAllAndOperator(): Unit {
        let treemap = TreeMap<String, Int64>()
        @Expect(treemap.size, 0)
        for ((k, v) in elementsNames) {
            treemap.add(k, v)
        }
        @Expect(treemap.size, 24)
        let strNames1: String = "[(ä½•, 21), (å†¯, 9), (å«, 12), (å•, 22), (å´, 6), (å‘¨, 5), (å­™, 3), (å°¤, 19), (å¼ , 24), (æ–½, 23), (æœ±, 17), (æ, 4), (æ¨, 16), (æ²ˆ, 14), (ç‹, 8), (ç§¦, 18), (è’‹, 13), (è¤š, 11), (è®¸, 20), (èµµ, 1), (éƒ‘, 7), (é’±, 2), (é™ˆ, 10), (éŸ©, 15)]"
        @Expect(treemap.toString(), strNames1)

        let elements1 = [("èµµ", 11), ("å´", 66), ("è¤š", 111), ("æ¨", 166), ("å°¤", 199), ("å•", 222), ("a", 96), ("b", 97)]

        treemap.add(all: elements1)
        @Expect(treemap.size, 26)

        var res = [("èµµ", 11), ("å´", 66), ("è¤š", 111), ("æ¨", 166), ("å°¤", 199), ("å•", 222)]
        for (tup in res) {
            @Expect(treemap.get(tup[0]).getOrThrow(), tup[1])
        }

        var value: ?Int64 = treemap.add("æµ‹è¯•", 369)
        @Assert(isNoneValue(value))
        value = treemap.add("æµ‹è¯•", 963)
        @Expect(value.getOrThrow(), 369)

        let strNames2: String = "[(a, 96), (b, 97), (ä½•, 21), (å†¯, 9), (å«, 12), (å•, 222), (å´, 66), (å‘¨, 5), (å­™, 3), (å°¤, 199), (å¼ , 24), (æ–½, 23), (æœ±, 17), (æ, 4), (æ¨, 166), (æ²ˆ, 14), (æµ‹è¯•, 963), (ç‹, 8), (ç§¦, 18), (è’‹, 13), (è¤š, 111), (è®¸, 20), (èµµ, 11), (éƒ‘, 7), (é’±, 2), (é™ˆ, 10), (éŸ©, 15)]"
        @Expect(treemap.toString(), strNames2)
    }

    @TestCase
    func removeAndAllAndIfAndClear(): Unit {
        var map: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x => (x, x * x)})
        @Expect(map.remove(0).getOrThrow(), 0)
        @Expect(isNoneValue(map.remove(0)))
        @Expect(isNoneValue(map.remove(10)))

        map.remove(all: [-2, 0, 1, 8])
        @Expect(isNoneValue(map.get(1)))
        @Expect(isNoneValue(map.get(8)))

        map.removeIf({key, _ => (key % 2 == 0)})
        @Expect(map.size, 4)
        @Expect(map.get(3).getOrThrow(), 9)
        @Expect(map.get(5).getOrThrow(), 25)
        @Expect(map.get(7).getOrThrow(), 49)
        @Expect(map.get(9).getOrThrow(), 81)

        map.clear()
        @Expect(map.size, 0)

        let treemap = TreeMap<String, Int64>(elementsRemove)
        let resStrRemove1: String = "[(!, 129), (#, 131), (%, 132), (&, 134), ((), 136), ((â—'â—¡'â—), 60), (*, 135), (1, 121), (2, 126), (3, 122), (4, 127), (5, 123), (6, 128), (7, 124), (9, 125), (:, 103), (;, 104), (<, 101), (>, 102), (@, 130), (B, 34), (D, 36), (F, 38), (G, 42), (H, 40), (K, 43), (M, 45), (O, 47), (Q, 49), (S, 51), (U, 53), (W, 55), (Y, 57), (^, 133), (a, 33), (c, 35), (e, 37), (g, 39), (i, 41), (l, 44), (n, 46), (p, 48), (r, 50), (t, 52), (v, 54), (x, 56), (z, 58), (Â£, 115), (Â¤, 120), (Â¥, 114), (â€², 116), (â„ƒ, 113), (â†, 137), (â†‘, 141), (â†“, 138), (â†”, 142), (â†–, 139), (â†—, 143), (â†™, 140), (â‡ , 144), (â¤, 105), (ãœ, 117), (ã„, 119), (ã, 118), (ä¸¥, 27), (ä¹, 93), (äº, 94), (äº‘, 53), (ä»», 70), (ä½•, 21), (ä¿, 69), (å€ª, 83), (å‚…, 96), (å†¯, 9), (å‡¤, 66), (å, 28), (å«, 12), (å², 75), (å•, 22), (å´, 6), (å‘¨, 5), (å”, 76), (å–», 48), (å¥š, 57), (å§œ, 32), (å­”, 25), (å­™, 3), (å®‰, 91), (å°¤, 19), (å²‘, 79), (å¸¸, 92), (å»‰, 78), (å¼ , 24), (å½­, 59), (æˆš, 45), (æ–¹, 68), (æ–½, 23), (æ—¶, 95), (æ˜Œ, 63), (æ›¹, 26), (æœ±, 17), (æ, 4), (æ¨, 16), (æŸ, 49), (æŸ³, 72), (æ®·, 86), (æ¯•, 88), (æ°´, 50), (æ±¤, 84), (æ²ˆ, 14), (æ»•, 85), (æ½˜, 55), (ç‹, 8), (ç§¦, 18), (çª¦, 51), (ç« , 52), (ç½—, 87), (èŠ±, 67), (è‹, 54), (è‹—, 65), (èŒƒ, 58), (è‘›, 56), (è’‹, 13), (è–›, 80), (è¢, 71), (è¤š, 11), (è®¸, 20), (è°¢, 46), (è´¹, 77), (è´º, 82), (èµµ, 1), (é‚¬, 90), (é‚¹, 47), (éƒ, 60), (éƒ‘, 7), (éƒ, 89), (é…†, 73), (é‡‘, 29), (é’±, 2), (é™ˆ, 10), (é™¶, 31), (é›·, 81), (éŸ¦, 62), (éŸ©, 15), (é©¬, 64), (é­, 30), (é², 61), (é², 74), (ğŸ’™, 109), (ğŸ’š, 108), (ğŸ’›, 107), (ğŸ’œ, 110), (ğŸ–¤, 112), (ğŸ˜‚, 99), (ğŸ˜ƒ, 59), (ğŸ˜Š, 98), (ğŸ˜¢, 97), (ğŸ¤, 111), (ğŸ¤£, 100), (ğŸ§¡, 106)]"
        @Expect(treemap.toString(), resStrRemove1)

        var size = elementsRemove.size
        @Expect(treemap.size, size)
        let results = [("å­™", 3), ("3", 122), (":", 103), ("â¤", 105), ("é­", 30), ("ğŸ˜‚", 99)]
        for (result in results) {
            @Expect(treemap.remove(result[0]).getOrThrow(), result[1])
            size--
            @Expect(treemap.size, size)
        }
        @Assert(isNoneValue(treemap.remove("None")))

        treemap.removeIf({k, _ => k <= "a"})
        @Expect(treemap.size, elementsRemove.size - 39)
        treemap.removeIf({_, v => (v >= 89 && v < 101)})
        @Expect(treemap.size, elementsRemove.size - 50)
        treemap.removeIf({k, _ => (k >= "å´" && k <= "æ›¹")})
        @Expect(treemap.size, elementsRemove.size - 67)
        let resStrRemove2: String = "[(c, 35), (e, 37), (g, 39), (i, 41), (l, 44), (n, 46), (p, 48), (r, 50), (t, 52), (v, 54), (x, 56), (z, 58), (Â£, 115), (Â¤, 120), (Â¥, 114), (â€², 116), (â„ƒ, 113), (â†, 137), (â†‘, 141), (â†“, 138), (â†”, 142), (â†–, 139), (â†—, 143), (â†™, 140), (â‡ , 144), (ãœ, 117), (ã„, 119), (ã, 118), (ä¸¥, 27), (äº‘, 53), (ä»», 70), (ä½•, 21), (ä¿, 69), (å€ª, 83), (å†¯, 9), (å‡¤, 66), (å, 28), (å«, 12), (å², 75), (å•, 22), (æœ±, 17), (æ, 4), (æ¨, 16), (æŸ, 49), (æŸ³, 72), (æ®·, 86), (æ¯•, 88), (æ°´, 50), (æ±¤, 84), (æ²ˆ, 14), (æ»•, 85), (æ½˜, 55), (ç‹, 8), (ç§¦, 18), (çª¦, 51), (ç« , 52), (ç½—, 87), (èŠ±, 67), (è‹, 54), (è‹—, 65), (èŒƒ, 58), (è‘›, 56), (è’‹, 13), (è–›, 80), (è¢, 71), (è¤š, 11), (è®¸, 20), (è°¢, 46), (è´¹, 77), (è´º, 82), (èµµ, 1), (é‚¹, 47), (éƒ, 60), (éƒ‘, 7), (é…†, 73), (é‡‘, 29), (é’±, 2), (é™ˆ, 10), (é™¶, 31), (é›·, 81), (éŸ¦, 62), (éŸ©, 15), (é©¬, 64), (é², 61), (é², 74), (ğŸ’™, 109), (ğŸ’š, 108), (ğŸ’›, 107), (ğŸ’œ, 110), (ğŸ–¤, 112), (ğŸ˜ƒ, 59), (ğŸ¤, 111), (ğŸ§¡, 106)]"
        @Expect(treemap.toString(), resStrRemove2)

        let elements1 = ["c", "e", "g", "i", "l", "n", "p", "r", "t", "v", "x", "z", "Â£", "Â¤", "Â¥", "â€²", "â„ƒ", "â†", "â†‘",
            "â†“", "â†”", "â†–", "â†—", "â†™", "â‡ ", "ãœ", "ã„", "ã"]
        treemap.remove(all: elements1)
        @Expect(treemap.size, elementsRemove.size - 95)
        let elements2 = ArrayList<String>()
        for ((k, _) in elementsRemove) {
            elements2.add(k)
        }
        treemap.remove(all: elements2)
        @Expect(treemap.isEmpty())

        treemap.add("a", 101)
        treemap.removeIf({k, _ => (k == "a")})
        @Expect(treemap.size, 0)

        treemap.add(all: elementsRemove)
        treemap.removeIf({k, _ => (k >= "å¼ " && k <= "é²")})
        let resStrRemove3: String = "[(!, 129), (#, 131), (%, 132), (&, 134), ((), 136), ((â—'â—¡'â—), 60), (*, 135), (1, 121), (2, 126), (3, 122), (4, 127), (5, 123), (6, 128), (7, 124), (9, 125), (:, 103), (;, 104), (<, 101), (>, 102), (@, 130), (B, 34), (D, 36), (F, 38), (G, 42), (H, 40), (K, 43), (M, 45), (O, 47), (Q, 49), (S, 51), (U, 53), (W, 55), (Y, 57), (^, 133), (a, 33), (c, 35), (e, 37), (g, 39), (i, 41), (l, 44), (n, 46), (p, 48), (r, 50), (t, 52), (v, 54), (x, 56), (z, 58), (Â£, 115), (Â¤, 120), (Â¥, 114), (â€², 116), (â„ƒ, 113), (â†, 137), (â†‘, 141), (â†“, 138), (â†”, 142), (â†–, 139), (â†—, 143), (â†™, 140), (â‡ , 144), (â¤, 105), (ãœ, 117), (ã„, 119), (ã, 118), (ä¸¥, 27), (ä¹, 93), (äº, 94), (äº‘, 53), (ä»», 70), (ä½•, 21), (ä¿, 69), (å€ª, 83), (å‚…, 96), (å†¯, 9), (å‡¤, 66), (å, 28), (å«, 12), (å², 75), (å•, 22), (å´, 6), (å‘¨, 5), (å”, 76), (å–», 48), (å¥š, 57), (å§œ, 32), (å­”, 25), (å­™, 3), (å®‰, 91), (å°¤, 19), (å²‘, 79), (å¸¸, 92), (å»‰, 78), (ğŸ’™, 109), (ğŸ’š, 108), (ğŸ’›, 107), (ğŸ’œ, 110), (ğŸ–¤, 112), (ğŸ˜‚, 99), (ğŸ˜ƒ, 59), (ğŸ˜Š, 98), (ğŸ˜¢, 97), (ğŸ¤, 111), (ğŸ¤£, 100), (ğŸ§¡, 106)]"
        @Expect(treemap.toString(), resStrRemove3)

        treemap.removeIf({k, _ => (k >= "!" && k <= ":")})
        treemap.removeIf({k, _ => (k >= "ä¸¥" && k <= "å»‰")})
        let resStrRemove4: String = "[(;, 104), (<, 101), (>, 102), (@, 130), (B, 34), (D, 36), (F, 38), (G, 42), (H, 40), (K, 43), (M, 45), (O, 47), (Q, 49), (S, 51), (U, 53), (W, 55), (Y, 57), (^, 133), (a, 33), (c, 35), (e, 37), (g, 39), (i, 41), (l, 44), (n, 46), (p, 48), (r, 50), (t, 52), (v, 54), (x, 56), (z, 58), (Â£, 115), (Â¤, 120), (Â¥, 114), (â€², 116), (â„ƒ, 113), (â†, 137), (â†‘, 141), (â†“, 138), (â†”, 142), (â†–, 139), (â†—, 143), (â†™, 140), (â‡ , 144), (â¤, 105), (ãœ, 117), (ã„, 119), (ã, 118), (ğŸ’™, 109), (ğŸ’š, 108), (ğŸ’›, 107), (ğŸ’œ, 110), (ğŸ–¤, 112), (ğŸ˜‚, 99), (ğŸ˜ƒ, 59), (ğŸ˜Š, 98), (ğŸ˜¢, 97), (ğŸ¤, 111), (ğŸ¤£, 100), (ğŸ§¡, 106)]"
        @Expect(treemap.toString(), resStrRemove4)
    }

    @TestCase
    func removeIfException(): Unit {
        let map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(
            [(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)])
        try {
            map1.removeIf(
                {
                    key: Int64, _: Int64 =>
                    map1.remove(key)
                    return false
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }

        try {
            map1.removeIf(
                {
                    _: Int64, _: Int64 =>
                    map1.removeLast()
                    return false
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }

        try {
            map1.removeIf(
                {
                    _: Int64, _: Int64 =>
                    map1.removeFirst()
                    return false
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }

        let map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(
            [(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)])
        try {
            map2.removeIf(
                {
                    key: Int64, _: Int64 =>
                    map2.remove(key)
                    return true
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }
    }

    @TestCase
    func removeIfPredicateClearException(): Unit {
        let map: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(
            [(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)])
        try {
            map.removeIf(
                {
                    _: Int64, _: Int64 =>
                    map.clear()
                    return false
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }
    }

    @TestCase
    func removeIfPredicateAddException(): Unit {
        let map: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(
            [(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)])
        try {
            map.removeIf(
                {
                    _: Int64, _: Int64 =>
                    map.add(10, 100)
                    return false
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }

        try {
            map.removeIf(
                {
                    _: Int64, _: Int64 =>
                    map.add(all: [(11, 121), (12, 144)])
                    return false
                }
            )
            @Expect("Should throw exception", "")
        } catch (e: ConcurrentModificationException) {
            @Expect(e.message, "The predicate cannot contain a modify operation.")
        }
    }

    @TestCase
    func sizeAndIsEmpty(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(map1.size, 0)
        @Expect(map1.isEmpty())
        var map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x => (x, x * 2 + 1)})
        @Expect(map2.size, 10)
        @Expect(!map2.isEmpty())
    }

    @TestCase
    func keysAndValues(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        @Expect(map1.keys().isEmpty())
        @Expect(map1.values().isEmpty())
        var map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x => (x, x * 2 + 1)})
        @Expect(map2.keys().toArray(), Array<Int64>(10, {x => x}))
        @Expect(map2.values().toArray(), Array<Int64>(10, {x => (x * 2 + 1)}))
    }

    @TestCase
    func operatorEqualAndUnequal(): Unit {
        var map1: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        var map2: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>()
        var map3: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(10, {x: Int64 => (x, x * x)})
        var map4: TreeMap<Int64, Int64> = TreeMap<Int64, Int64>(
            [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)])
        @Expect(map1 == map2)
        @Expect(map1 != map2, false)
        @Expect(map3 == map4)
        @Expect(map3 != map4, false)
        @Expect(map1 != map3)
        @Expect(map2 != map4)
    }
}
